#!/usr/bin/env node
import path from "path";
import { exit } from "process";

import type {
  HealthIssue,
  HealthIssueLevel,
} from "../health/registry";
import {
  loadHealthHistoryRecords,
  type HealthHistoryRecordWithPath,
  type SkippedHealthHistoryFile,
} from "../health/historyReader";

type TimelineChange = "created" | "updated" | "resolved";

type TimelineEntry = {
  issueId: string;
  kind: "report" | "resolve";
  change: TimelineChange;
  recordedAt: string | null;
  filePath: string;
  issue: HealthIssue;
  previous: HealthIssue | null;
};

type IssueAggregate = {
  id: string;
  level: HealthIssueLevel;
  message: string;
  firstRecordedAt: string | null;
  lastRecordedAt: string | null;
  firstDetectedAt: string | null;
  lastDetectedAt: string | null;
  active: boolean;
  lastEvent: TimelineChange;
  reportCount: number;
  createdCount: number;
  updateCount: number;
  resolveCount: number;
  resolvedAt: string | null;
  lastFilePath: string | null;
  history: TimelineEntry[];
};

type AggregationResult = {
  issues: IssueAggregate[];
  issueMap: Map<string, IssueAggregate>;
  timeline: TimelineEntry[];
};

const usage = `„Éò„É´„ÇπÂ±•Ê≠¥„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ

‰Ωø„ÅÑÊñπ:
  npm run health-history -- summary
  npm run health-history -- detail <issue-id>
  npm run health-history -- timeline [--limit <‰ª∂Êï∞>]

Ë™¨Êòé:
  summary   : „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÂïèÈ°å„ÅÆÈõÜË®àÁµêÊûú„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
  detail    : ÊåáÂÆö„Åó„Åü issue-id „ÅÆË©≥Á¥∞„Çø„Ç§„É†„É©„Ç§„É≥„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
  timeline  : Áõ¥Ëøë„ÅÆ„Éò„É´„Çπ„Ç§„Éô„É≥„Éà„ÇíÊôÇÁ≥ªÂàó„ÅßË°®Á§∫„Åó„Åæ„ÅôÔºàÊó¢ÂÆö 20 ‰ª∂Ôºâ„ÄÇ
`;

const reportSkippedFiles = (skipped: SkippedHealthHistoryFile[]) => {
  if (skipped.length === 0) {
    return;
  }

  console.warn(
    `\u26a0\ufe0f ${skipped.length} ‰ª∂„ÅÆ„Éò„É´„ÇπÂ±•Ê≠¥„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÅ„Å™„Åã„Å£„Åü„Åü„ÇÅ„ÄÅÈõÜË®àÂØæË±°„Åã„ÇâÈô§Â§ñ„Åó„Åæ„Åó„Åü„ÄÇ`
  );

  const preview = skipped.slice(0, 5);
  for (const item of preview) {
    const relativePath = path.relative(process.cwd(), item.filePath);
    console.warn(`  - ${relativePath}: ${item.reason}`);
  }

  if (skipped.length > preview.length) {
    console.warn(`  ...‰ªñ ${skipped.length - preview.length} ‰ª∂`);
  }
};

const toIsoOrNull = (value: string | null | undefined): string | null => {
  if (!value) {
    return null;
  }

  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toISOString();
};

const formatTimestamp = (value: string | null | undefined): string =>
  value ?? "-";

const levelPriority = (level: HealthIssueLevel) =>
  level === "error" ? 0 : 1;

const statusIcon = (issue: IssueAggregate) => {
  if (issue.active) {
    return issue.level === "error" ? "üü•" : "üüß";
  }
  if (issue.resolveCount > 0) {
    return "üü©";
  }
  return "‚¨úÔ∏è";
};

const levelLabel = (level: HealthIssueLevel) =>
  level === "error" ? "„Ç®„É©„Éº" : "Ë≠¶Âëä";

const eventLabel = (entry: TimelineEntry) => {
  if (entry.kind === "resolve") {
    return "Ëß£Ê∂à";
  }
  return entry.change === "created" ? "Êñ∞Ë¶èÊ§úÁü•" : "ÂÜÖÂÆπÊõ¥Êñ∞";
};

const formatDetailValue = (value: unknown) => {
  if (value === null) {
    return "null";
  }
  if (value === undefined) {
    return "undefined";
  }
  if (typeof value === "string") {
    return value.length > 80 ? `${value.slice(0, 77)}‚Ä¶` : value;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  try {
    const json = JSON.stringify(value);
    return json.length > 120 ? `${json.slice(0, 117)}‚Ä¶` : json;
  } catch {
    return String(value);
  }
};

const formatDetails = (details: Record<string, unknown> | undefined) => {
  if (!details) {
    return null;
  }

  const entries = Object.entries(details);
  if (entries.length === 0) {
    return null;
  }

  const lines = entries.slice(0, 5).map(
    ([key, value]) => `${key}: ${formatDetailValue(value)}`
  );

  if (entries.length > 5) {
    lines.push(`‚Ä¶‰ªñ ${entries.length - 5} ‰ª∂`);
  }

  return lines.join(" / ");
};

const aggregateHistory = (
  records: HealthHistoryRecordWithPath[]
): AggregationResult => {
  const issueMap = new Map<string, IssueAggregate>();
  const timeline: TimelineEntry[] = [];

  for (const entry of records) {
    const snapshot =
      entry.record.type === "report"
        ? entry.record.issue
        : entry.record.issue;
    const recordedAt = toIsoOrNull(entry.record.recorded_at);
    const detectedAt = toIsoOrNull(snapshot.detectedAt);
    const issueId = snapshot.id;

    let aggregate = issueMap.get(issueId);
    if (!aggregate) {
      aggregate = {
        id: issueId,
        level: snapshot.level,
        message: snapshot.message,
        firstRecordedAt: recordedAt,
        lastRecordedAt: recordedAt,
        firstDetectedAt: detectedAt,
        lastDetectedAt: detectedAt,
        active: true,
        lastEvent:
          entry.record.type === "report" ? entry.record.change : "resolved",
        reportCount: 0,
        createdCount: 0,
        updateCount: 0,
        resolveCount: 0,
        resolvedAt: null,
        lastFilePath: entry.filePath,
        history: [],
      };
      issueMap.set(issueId, aggregate);
    }

    if (!aggregate.firstRecordedAt && recordedAt) {
      aggregate.firstRecordedAt = recordedAt;
    }
    if (recordedAt) {
      aggregate.lastRecordedAt = recordedAt;
    }
    if (!aggregate.firstDetectedAt && detectedAt) {
      aggregate.firstDetectedAt = detectedAt;
    }
    if (detectedAt) {
      aggregate.lastDetectedAt = detectedAt;
    }

    aggregate.level = snapshot.level;
    aggregate.message = snapshot.message;
    aggregate.lastFilePath = entry.filePath;

    const timelineEntry: TimelineEntry = {
      issueId,
      kind: entry.record.type,
      change:
        entry.record.type === "report"
          ? entry.record.change
          : "resolved",
      recordedAt,
      filePath: entry.filePath,
      issue: snapshot,
      previous:
        entry.record.type === "report" ? entry.record.previous : null,
    };

    timeline.push(timelineEntry);
    aggregate.history.push(timelineEntry);

    if (entry.record.type === "report") {
      aggregate.reportCount += 1;
      if (entry.record.change === "created") {
        aggregate.createdCount += 1;
      } else {
        aggregate.updateCount += 1;
      }
      aggregate.lastEvent = entry.record.change;
      aggregate.active = true;
      aggregate.resolvedAt = null;
    } else {
      aggregate.resolveCount += 1;
      aggregate.lastEvent = "resolved";
      aggregate.active = false;
      if (recordedAt) {
        aggregate.resolvedAt = recordedAt;
      }
    }
  }

  const issues = Array.from(issueMap.values()).sort((a, b) => {
    if (a.active !== b.active) {
      return a.active ? -1 : 1;
    }
    const levelDiff = levelPriority(a.level) - levelPriority(b.level);
    if (levelDiff !== 0) {
      return levelDiff;
    }
    const aTime = a.lastRecordedAt ?? "";
    const bTime = b.lastRecordedAt ?? "";
    return bTime.localeCompare(aTime);
  });

  const timelineDescending = [...timeline].sort((a, b) => {
    const aKey = a.recordedAt ?? "";
    const bKey = b.recordedAt ?? "";
    return bKey.localeCompare(aKey);
  });

  return { issues, issueMap, timeline: timelineDescending };
};

const printIssueSummary = (issue: IssueAggregate) => {
  const icon = statusIcon(issue);
  const status = issue.active
    ? "Êú™Ëß£Ê∂à (Á∂ôÁ∂ö‰∏≠)"
    : issue.resolveCount > 0
      ? `Ëß£Ê∂àÊ∏à„Åø (${formatTimestamp(issue.resolvedAt)})`
      : "Áä∂ÊÖã‰∏çÊòé";
  const lastEventLabel =
    issue.lastEvent === "resolved"
      ? "Ëß£Ê∂à"
      : issue.lastEvent === "created"
        ? "Êñ∞Ë¶èÊ§úÁü•"
        : "ÂÜÖÂÆπÊõ¥Êñ∞";
  const fileLabel = issue.lastFilePath
    ? path.relative(process.cwd(), issue.lastFilePath)
    : "-";

  console.log(`${icon} ${issue.id}`);
  console.log(`  Áä∂ÊÖã        : ${status}`);
  console.log(`  „É¨„Éô„É´      : ${levelLabel(issue.level)}`);
  console.log(`  ÂàùÂõûÊ§úÁü•    : ${formatTimestamp(issue.firstDetectedAt)}`);
  console.log(`  ÊúÄÊñ∞Ê§úÁü•    : ${formatTimestamp(issue.lastDetectedAt)}`);
  console.log(`  ÊúÄÁµÇ„Ç§„Éô„É≥„Éà: ${lastEventLabel} (${formatTimestamp(issue.lastRecordedAt)})`);
  console.log(
    `  „É¨„Éù„Éº„ÉàÊï∞  : ${issue.reportCount} (Êñ∞Ë¶è ${issue.createdCount} / Êõ¥Êñ∞ ${issue.updateCount})`
  );
  console.log(`  Ëß£Ê∂àÂõûÊï∞    : ${issue.resolveCount}`);
  console.log(`  ÊúÄÁµÇ„Éï„Ç°„Ç§„É´: ${fileLabel}`);
  console.log(`  „É°„ÉÉ„Çª„Éº„Ç∏  : ${issue.message}`);
};

const runSummary = async () => {
  const { records, skipped } = await loadHealthHistoryRecords();
  reportSkippedFiles(skipped);

  if (records.length === 0) {
    console.log("„Éò„É´„ÇπÂ±•Ê≠¥„ÅØ„Åæ„Å†Ë®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
    return;
  }

  const aggregation = aggregateHistory(records);
  if (aggregation.issues.length === 0) {
    console.log("Ëß£ÊûêÂØæË±°„Å®„Å™„Çã„Éò„É´„ÇπÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ");
    return;
  }

  console.log(
    `„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÂ±•Ê≠¥: ${aggregation.issues.length} ‰ª∂„ÅÆ issue „ÇíÈõÜË®à„Åó„Åæ„Åó„Åü„ÄÇ`
  );
  console.log("----------------------------------------");

  for (const issue of aggregation.issues) {
    printIssueSummary(issue);
    console.log("");
  }

  const activeCount = aggregation.issues.filter((issue) => issue.active).length;
  const resolvedCount =
    aggregation.issues.length - activeCount;

  console.log(
    `ÂÜÖË®≥: Á∂ôÁ∂ö‰∏≠ ${activeCount} ‰ª∂ / Ëß£Ê∂àÊ∏à„Åø ${resolvedCount} ‰ª∂`
  );
};

const printUpdateDifferences = (entry: TimelineEntry) => {
  if (entry.kind !== "report" || entry.change !== "updated" || !entry.previous) {
    return;
  }

  const changes: string[] = [];
  if (entry.previous.level !== entry.issue.level) {
    changes.push(
      `„É¨„Éô„É´: ${levelLabel(entry.previous.level)} ‚Üí ${levelLabel(entry.issue.level)}`
    );
  }
  if (entry.previous.message !== entry.issue.message) {
    changes.push("„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åó„Åü„ÄÇ");
  }
  if (entry.previous.details && entry.issue.details) {
    const prevKeys = Object.keys(entry.previous.details);
    const nextKeys = Object.keys(entry.issue.details);
    if (prevKeys.length !== nextKeys.length) {
      changes.push("Ë©≥Á¥∞„Éï„Ç£„Éº„É´„ÉâÊï∞„ÅåÂ§âÊõ¥„Åï„Çå„Åæ„Åó„Åü„ÄÇ");
    }
  }

  if (changes.length > 0) {
    for (const change of changes) {
      console.log(`    Â§âÊõ¥      : ${change}`);
    }
  }
};

const printTimelineEntry = (entry: TimelineEntry) => {
  const recorded = formatTimestamp(entry.recordedAt);
  const label = eventLabel(entry);
  const fileLabel = path.relative(process.cwd(), entry.filePath);

  console.log(`- ${recorded} ${label}`);
  console.log(`    „É¨„Éô„É´    : ${levelLabel(entry.issue.level)}`);
  console.log(`    Ê§úÁü•ÊôÇÂàª  : ${formatTimestamp(entry.issue.detectedAt)}`);
  console.log(`    „É°„ÉÉ„Çª„Éº„Ç∏: ${entry.issue.message}`);

  const details = formatDetails(entry.issue.details);
  if (details) {
    console.log(`    Ë©≥Á¥∞      : ${details}`);
  }

  printUpdateDifferences(entry);
  console.log(`    Â±•Ê≠¥„Éï„Ç°„Ç§„É´: ${fileLabel}`);
};

const runDetail = async (issueId: string | undefined) => {
  if (!issueId) {
    console.error("detail „Ç≥„Éû„É≥„Éâ„Å´„ÅØ issue-id „ÅÆÊåáÂÆö„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ");
    console.log(usage);
    exit(1);
  }

  const { records, skipped } = await loadHealthHistoryRecords();
  reportSkippedFiles(skipped);

  if (records.length === 0) {
    console.log("„Éò„É´„ÇπÂ±•Ê≠¥„ÅØ„Åæ„Å†Ë®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
    exit(0);
  }

  const aggregation = aggregateHistory(records);
  const target = aggregation.issueMap.get(issueId);

  if (!target) {
    console.error(`ÊåáÂÆö„Åï„Çå„Åü issue-id (${issueId}) „ÅÆÂ±•Ê≠¥„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ`);
    if (aggregation.issues.length > 0) {
      console.log("Âà©Áî®ÂèØËÉΩ„Å™ issue-id:");
      for (const issue of aggregation.issues.slice(0, 10)) {
        console.log(`  - ${issue.id}`);
      }
      if (aggregation.issues.length > 10) {
        console.log("  (‰ªñ„Å´„ÇÇ issue „ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇsummary „Ç≥„Éû„É≥„Éâ„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ)");
      }
    }
    exit(1);
  }

  printIssueSummary(target);
  console.log("");
  console.log("„Çø„Ç§„É†„É©„Ç§„É≥:");
  console.log("-------------");

  if (target.history.length === 0) {
    console.log("„Åì„ÅÆ issue „ÅÆÂ±•Ê≠¥„Ç§„Éô„É≥„Éà„ÅØË®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
    return;
  }

  for (const entry of target.history) {
    printTimelineEntry(entry);
    console.log("");
  }
};

const parseLimit = (args: string[], defaultValue: number) => {
  const index = args.indexOf("--limit");
  if (index === -1) {
    return defaultValue;
  }

  const raw = args[index + 1];
  if (!raw) {
    console.error("--limit „Ç™„Éó„Ç∑„Éß„É≥„Å´„ÅØÊï∞ÂÄ§„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    exit(1);
  }

  const value = Number.parseInt(raw, 10);
  if (!Number.isFinite(value) || value <= 0) {
    console.error("--limit „Ç™„Éó„Ç∑„Éß„É≥„ÅØ 1 ‰ª•‰∏ä„ÅÆÊï¥Êï∞„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    exit(1);
  }

  return value;
};

const runTimeline = async (args: string[]) => {
  const limit = parseLimit(args, 20);
  const { records, skipped } = await loadHealthHistoryRecords();
  reportSkippedFiles(skipped);

  if (records.length === 0) {
    console.log("„Éò„É´„ÇπÂ±•Ê≠¥„ÅØ„Åæ„Å†Ë®òÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
    return;
  }

  const aggregation = aggregateHistory(records);
  if (aggregation.timeline.length === 0) {
    console.log("„Éò„É´„Çπ„Ç§„Éô„É≥„Éà„ÅÆÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ");
    return;
  }

  console.log(`Áõ¥Ëøë ${Math.min(limit, aggregation.timeline.length)} ‰ª∂„ÅÆ„Éò„É´„Çπ„Ç§„Éô„É≥„Éà:`);
  console.log("-------------");

  for (const entry of aggregation.timeline.slice(0, limit)) {
    const recorded = formatTimestamp(entry.recordedAt);
    const label = eventLabel(entry);
    const level = levelLabel(entry.issue.level);

    console.log(`- ${recorded} ${label} [${entry.issueId}] (${level})`);
    console.log(`    „É°„ÉÉ„Çª„Éº„Ç∏: ${entry.issue.message}`);

    const details = formatDetails(entry.issue.details);
    if (details) {
      console.log(`    Ë©≥Á¥∞      : ${details}`);
    }

    console.log(
      `    Â±•Ê≠¥„Éï„Ç°„Ç§„É´: ${path.relative(process.cwd(), entry.filePath)}`
    );
    console.log("");
  }
};

const main = async () => {
  const command = process.argv[2] ?? "summary";
  const args = process.argv.slice(3);

  if (command === "summary") {
    await runSummary();
    return;
  }

  if (command === "detail") {
    await runDetail(args[0]);
    return;
  }

  if (command === "timeline") {
    await runTimeline(args);
    return;
  }

  if (command === "--help" || command === "-h") {
    console.log(usage);
    return;
  }

  console.error(`‰∏çÊòé„Å™„Ç≥„Éû„É≥„Éâ„Åß„Åô: ${command}`);
  console.log(usage);
  exit(1);
};

main().catch((error) => {
  console.error("„Éò„É´„ÇπÂ±•Ê≠¥„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÅÆÂÆüË°å‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", error);
  exit(1);
});
